The thought process when creating this program was to simplify the complexities of BlackJack and abstract the game into objects and classes. A BlackJack game consists of a player and dealer which have their own attributes such as a hand of cards, hand value, funds, and bid amount. The cards in a hand are drawn from a deck which have functions such as shuffling and drawing a random card. The cards itself have a suit label and rank value.

The Card class was constructed from an enumeration structure because the suit labels and rank values are constant. It made it easy to represent cards with the necessary information to create a full deck of cards. A Card object had two fields for a suit and a rank. A suit and rank were defined using an enum where the suit had labels of either KING, SPADE, CLUB, or HEART. The rank was defined as having a label and also an integer value of the rank. This made it simple to distinguish between face values such as KING, QUEEN, and JACK cards from tens because although they have the same rank value, the labels are different. The cards also had another field for determining whether they were face up or down. This was important for the dealer because the second card is always face down until the player completes their turn. The challenge in this implementation is that the ACE value in BlackJack is not constant. The ACE value can be a 1 or 11 depending on the player’s decision. We decided to create two ACE rank values ACE and ACE11 where ACE represents a rank of 1 and ACE11 represents a rank of 11. This made it easy to switch between a card rank value.

The Deck class consists of an ArrayList of Cards that represents the deck the BlackJack game is played from. An ArrayList data structure was chosen because it could interface with the Card Objects and it had many useful methods that helped achieve many of the desired Deck functions. A deck consists of 52 cards where one card of each rank for a given suit is present. We used a random object to randomly select cards and shuffle a deck. We also used a random object to select a card from that deck when dealing to a player or dealer. After a card draw, we used a remove function to take the card out of the deck being used, so that it can’t be drawn again. This functionality simulates real life BlackJack, where each game begins with a shuffled deck of 52 cards and cards are not replaced when cards are drawn. 

A Player class represents a player and tracks important attributes such as the integer value of their funds and bid and ArrayList of their hand of cards. The getter and setter methods for these attributes allow for the update of these values. The bet of a player is controlled from the GUI in increments of $1, $10, $100, and $1000. The funds of a player updated after winning/losing/pushing a bet. A new card can also be added to the player’s hand and the hand value can be determined. These attributes and methods were duplicated in the Player class for the split hand because we need two separate ways of tracking these values and manipulating them. It didn’t make sense to create another player object to represent a split hand. There is only going to be one split hand and we won't need to handle situations of a split hand having to split again. Furthermore, the split hand bid is going to impact the player’s fund so everything should be self-contained in the player class. The player class is also used to construct the dealer. The additional methods meant only for the dealer include the containsNewAce method which finds a new ace in the dealer's hand and changes it value depending on the hand value without the ace. An ace should increase to an 11 when the hand value without the ace is below or equal to ten and an ace should stay a 1 when the hand value without the ace is greater than 10. This increases the opportunity for the dealer to win more often when having aces in their hand.

The GamePlay class provides the structure for actually playing a game. It creates two players (one dealer and one user) and a new deck. Using the draw function (which returns a card) in the deck class and the add function in the player class, the dealer is initially dealt two cards. Then the GUI prompts the user to hit or hold; If they hit then another card is dealt. Once the user has exceeded 21 or decides to hold, it is the dealer’s turn to draw. The dealer hit and user hit are different methods because the user hit requires user input and the dealer hit is based on predetermined logic. GamePlayer then prints the winner and determines the earnings based on a series of checks, using if else statements. If the dealer hand is less than 21 and is greater than the user’s, or if the user’s hand exceeds 21, then the dealer wins and the user loses the amount of their bid. If the inverse is true then the user wins and gains the amount of their bid. If the hands are equal then it is considered a push and the user neither gains nor loses money. The GamePlay class also contains the paint method which generates and updates the graphics of the game. The boolean game and splitGame control the flow of the game by drawing the appropriate graphics whe the player has one or two hands. It also draws the pop-up graphics for prompting users whether they want to split their hand, change their ace value, and continuing their hand or completing their hand bid. It was decided that the pop-up graphics should appear in the top-right of the window because it wouldn’t overlap with the graphics of the dealer and player hand. The bid increments were placed at the bottom of the user's hand and were oval because casinos use poker chips to place a bid and are easier to access at the bottom of the window. The bid button was included to ensure the user places a bid before hitting for a card. The double down was included to allow users to double down after having a favorable first two card draw. The game results were printed over the player’s hand in a white background because it provides the best readability without overlapping too many graphics.

The DeckGenerator class draws the cards in the hand of the dealer and the player. A boolean split is used to determine whether only the hand or the hand and split hand should be drawn. This allows for control of the spacing of the cards when drawn and is important because drawing two hands on one screen requires a lot of space. The hand value, funds, and the bid of the player is also printed next to the respective hands. The dealer has its own draw method because it needs to draw the dealer's hand while only printing the hand value of its first card until the player's turn is over. The cards were printed in an overlapping fashion such that the players could still see their hand cards because it’s visually appealing to see cards laid out like on a real poker table. 

The RectButton and OvalButton class facilitated the process of creating the buttons needed for the game. Both classes have similar code but draw different shapes such as a rectangle or ellipse. Both represent a shape with a label that is printed in the center of the buttons. A TextAlignment class was written to help center a string of text in the center of ovals and rectangles. These classes helped factor out and clean a lot of the Gameplay class code.

The GameListener class handled all of the user mouse click inputs and the action performed off of those inputs. The class depended on the gameplay class because it contained all of the game objects such as the buttons and the player. The mouseClicked method was structured in an if/elseif/else loop where the if branch was executed when the player hand did not bust or held meaning the boolean game was true. The else if branch was executed when the game was false and splitGame was true meaning the first hand had it’s turn and now it’s the second split hand turn. When both game and splitGame were false, then the player had completed its turn and a new turn would start with the game logic and hands for the dealer and player reset. The code within the if and else if branches are very similar in that they share the same code for hitting, holding, and changing ace values. The branches were structured this way so that the first hand would finish first then the second hand could continue its turn. The if branch for the game boolean has more nested if statements because of the ability to split your first hand and not your already split hand. Furthermore, only the first hand can use the increment bid buttons because the split hand has to copy the original hand bet. The split hand could, however, double its bet. The if branch also has an if/elseif structure with the ace buttons and the split buttons because since they overlap, there was an issue where splitting a hand results in adding an ace to the hand. This is a fix for that issue.
